import { fileURLToPath } from 'node:url';
import { join, normalize, resolve } from 'pathe';
import { defineNuxtModule, addVitePlugin, addServerHandler, addServerPlugin, installModule } from '@nuxt/kit';
import { createDefu, defu } from 'defu';
import viteRemove from 'unplugin-remove/vite';
import { createHash } from 'node:crypto';
import { existsSync } from 'node:fs';
import { readdir, readFile, mkdir, writeFile } from 'node:fs/promises';

const defuReplaceArray = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) || Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});

const defaultThrowErrorValue = { throwError: true };
const defaultSecurityConfig = (serverlUrl) => ({
  headers: {
    crossOriginResourcePolicy: "same-origin",
    crossOriginOpenerPolicy: "same-origin",
    crossOriginEmbedderPolicy: "require-corp",
    contentSecurityPolicy: {
      "base-uri": ["'none'"],
      "font-src": ["'self'", "https:", "data:"],
      "form-action": ["'self'"],
      "frame-ancestors": ["'self'"],
      "img-src": ["'self'", "data:"],
      "object-src": ["'none'"],
      "script-src-attr": ["'none'"],
      "style-src": ["'self'", "https:", "'unsafe-inline'"],
      "script-src": ["'self'", "https:", "'unsafe-inline'", "'strict-dynamic'", "'nonce-{{nonce}}'"],
      "upgrade-insecure-requests": true
    },
    originAgentCluster: "?1",
    referrerPolicy: "no-referrer",
    strictTransportSecurity: {
      maxAge: 15552e3,
      includeSubdomains: true
    },
    xContentTypeOptions: "nosniff",
    xDNSPrefetchControl: "off",
    xDownloadOptions: "noopen",
    xFrameOptions: "SAMEORIGIN",
    xPermittedCrossDomainPolicies: "none",
    xXSSProtection: "0",
    permissionsPolicy: {
      camera: [],
      "display-capture": [],
      fullscreen: [],
      geolocation: [],
      microphone: []
    }
  },
  requestSizeLimiter: {
    maxRequestSizeInBytes: 2e6,
    maxUploadFileRequestInBytes: 8e6,
    ...defaultThrowErrorValue
  },
  rateLimiter: {
    // Twitter search rate limiting
    tokensPerInterval: 150,
    interval: 3e5,
    headers: false,
    driver: {
      name: "lruCache"
    },
    ...defaultThrowErrorValue
  },
  xssValidator: {
    methods: ["GET", "POST"],
    ...defaultThrowErrorValue
  },
  corsHandler: {
    // Options by CORS middleware for Express https://github.com/expressjs/cors#configuration-options
    origin: serverlUrl,
    methods: ["GET", "HEAD", "PUT", "PATCH", "POST", "DELETE"],
    preflight: {
      statusCode: 204
    }
  },
  allowedMethodsRestricter: {
    methods: "*",
    ...defaultThrowErrorValue
  },
  hidePoweredBy: true,
  basicAuth: false,
  enabled: true,
  csrf: false,
  nonce: true,
  // https://github.com/Talljack/unplugin-remove/blob/main/src/types.ts
  removeLoggers: {
    external: [],
    consoleType: ["log", "debug"],
    include: [/\.[jt]sx?$/, /\.vue\??/],
    exclude: [/node_modules/, /\.git/]
  },
  ssg: {
    meta: true,
    hashScripts: true,
    hashStyles: false
  },
  sri: true
});

const KEYS_TO_NAMES = {
  contentSecurityPolicy: "Content-Security-Policy",
  crossOriginEmbedderPolicy: "Cross-Origin-Embedder-Policy",
  crossOriginOpenerPolicy: "Cross-Origin-Opener-Policy",
  crossOriginResourcePolicy: "Cross-Origin-Resource-Policy",
  originAgentCluster: "Origin-Agent-Cluster",
  referrerPolicy: "Referrer-Policy",
  strictTransportSecurity: "Strict-Transport-Security",
  xContentTypeOptions: "X-Content-Type-Options",
  xDNSPrefetchControl: "X-DNS-Prefetch-Control",
  xDownloadOptions: "X-Download-Options",
  xFrameOptions: "X-Frame-Options",
  xPermittedCrossDomainPolicies: "X-Permitted-Cross-Domain-Policies",
  xXSSProtection: "X-XSS-Protection",
  permissionsPolicy: "Permissions-Policy"
};
const NAMES_TO_KEYS = Object.fromEntries(Object.entries(KEYS_TO_NAMES).map(([key, name]) => [name, key]));
function getKeyFromName(headerName) {
  const [, key] = Object.entries(NAMES_TO_KEYS).find(([name]) => name.toLowerCase() === headerName.toLowerCase()) || [];
  return key;
}
function headerStringFromObject(optionKey, optionValue) {
  if (optionValue === false) {
    return "";
  }
  if (optionKey === "contentSecurityPolicy") {
    const policies = optionValue;
    return Object.entries(policies).filter(([, value]) => value !== false).map(([directive, sources]) => {
      if (directive === "upgrade-insecure-requests") {
        return "upgrade-insecure-requests;";
      } else {
        const stringifiedSources = typeof sources === "string" ? sources : sources.map((source) => source.trim()).join(" ");
        return `${directive} ${stringifiedSources};`;
      }
    }).join(" ");
  } else if (optionKey === "strictTransportSecurity") {
    const policies = optionValue;
    return [
      `max-age=${policies.maxAge};`,
      policies.includeSubdomains && "includeSubDomains;",
      policies.preload && "preload;"
    ].filter(Boolean).join(" ");
  } else if (optionKey === "permissionsPolicy") {
    const policies = optionValue;
    return Object.entries(policies).filter(([, value]) => value !== false).map(([directive, sources]) => {
      if (typeof sources === "string") {
        return `${directive}=${sources}`;
      } else {
        return `${directive}=(${sources.join(" ")})`;
      }
    }).join(", ");
  } else {
    return optionValue;
  }
}
function headerObjectFromString(optionKey, headerValue) {
  if (!headerValue) {
    return false;
  }
  if (optionKey === "contentSecurityPolicy") {
    const directives = headerValue.split(";").map((directive) => directive.trim()).filter((directive) => directive);
    const objectForm = {};
    for (const directive of directives) {
      const [type, ...sources] = directive.split(" ").map((token) => token.trim());
      if (type === "upgrade-insecure-requests") {
        objectForm[type] = true;
      } else {
        objectForm[type] = sources.join(" ");
      }
    }
    return objectForm;
  } else if (optionKey === "strictTransportSecurity") {
    const directives = headerValue.split(";").map((directive) => directive.trim()).filter((directive) => directive);
    const objectForm = {};
    for (const directive of directives) {
      const [type, value] = directive.split("=").map((token) => token.trim());
      if (type === "max-age") {
        objectForm.maxAge = Number(value);
      } else if (type === "includeSubdomains" || type === "preload") {
        objectForm[type] = true;
      }
    }
    return objectForm;
  } else if (optionKey === "permissionsPolicy") {
    const directives = headerValue.split(",").map((directive) => directive.trim()).filter((directive) => directive);
    const objectForm = {};
    for (const directive of directives) {
      const [type, value] = directive.split("=").map((token) => token.trim());
      objectForm[type] = value;
    }
    return objectForm;
  } else {
    return headerValue;
  }
}

async function hashBundledAssets(nitro) {
  const hashAlgorithm = "sha384";
  const sriHashes = {};
  const { cdnURL: appCdnUrl = "", baseURL: appBaseUrl } = nitro.options.runtimeConfig.app;
  const publicAssets = nitro.options.publicAssets;
  for (const publicAsset of publicAssets) {
    const { dir, baseURL = "" } = publicAsset;
    if (existsSync(dir)) {
      const entries = await readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isFile()) {
          const fullPath = join(dir, entry.name);
          const fileContent = await readFile(fullPath);
          const hash = generateHash(fileContent, hashAlgorithm);
          const relativeUrl = join(baseURL, entry.name);
          let url;
          if (appCdnUrl) {
            url = new URL(relativeUrl, appCdnUrl).href;
          } else {
            url = join("/", appBaseUrl, relativeUrl);
          }
          sriHashes[url] = hash;
        }
      }
    }
  }
  const buildDir = nitro.options.buildDir;
  const integrityDir = join(buildDir, "integrity");
  if (!existsSync(integrityDir)) {
    await mkdir(integrityDir);
  }
  const hashFilePath = join(integrityDir, "sriHashes.json");
  await writeFile(hashFilePath, JSON.stringify(sriHashes));
  nitro.options.serverAssets.push({ dir: integrityDir, baseName: "integrity" });
}
function generateHash(content, hashAlgorithm) {
  const hash = createHash(hashAlgorithm);
  hash.update(content);
  return `${hashAlgorithm}-${hash.digest("base64")}`;
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-security",
    configKey: "security"
  },
  async setup(options, nuxt) {
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    nuxt.options.build.transpile.push(runtimeDir);
    nuxt.options.security = defuReplaceArray(
      { ...options, ...nuxt.options.security },
      {
        ...defaultSecurityConfig(nuxt.options.devServer.url)
      }
    );
    const securityOptions = nuxt.options.security;
    if (!securityOptions.enabled) {
      return;
    }
    if (securityOptions.removeLoggers) {
      addVitePlugin(viteRemove(securityOptions.removeLoggers));
    }
    registerSecurityNitroPlugins(nuxt, securityOptions);
    nuxt.options.runtimeConfig.private = defu(
      nuxt.options.runtimeConfig.private,
      {
        basicAuth: securityOptions.basicAuth
      }
    );
    delete securityOptions.basicAuth;
    nuxt.options.runtimeConfig.security = defu(
      nuxt.options.runtimeConfig.security,
      {
        ...securityOptions
      }
    );
    setGlobalSecurityRoute(nuxt, securityOptions);
    mergeSecurityPerRoute(nuxt);
    addServerHandler({
      handler: normalize(
        resolve(runtimeDir, "server/middleware/cspNonceHandler")
      )
    });
    if (nuxt.options.security.requestSizeLimiter) {
      addServerHandler({
        handler: normalize(
          resolve(runtimeDir, "server/middleware/requestSizeLimiter")
        )
      });
    }
    if (nuxt.options.security.rateLimiter) {
      addServerHandler({
        handler: normalize(
          resolve(runtimeDir, "server/middleware/rateLimiter")
        )
      });
    }
    if (nuxt.options.security.xssValidator) {
      nuxt.options.security.xssValidator.methods = Array.from(new Set(nuxt.options.security.xssValidator.methods));
      addServerHandler({
        handler: normalize(
          resolve(runtimeDir, "server/middleware/xssValidator")
        )
      });
    }
    if (nuxt.options.security.corsHandler) {
      addServerHandler({
        handler: normalize(
          resolve(runtimeDir, "server/middleware/corsHandler")
        )
      });
    }
    if (nuxt.options.security.runtimeHooks) {
      addServerPlugin(resolve(runtimeDir, "nitro/plugins/00-context"));
    }
    const allowedMethodsRestricterConfig = nuxt.options.security.allowedMethodsRestricter;
    if (allowedMethodsRestricterConfig && !Object.values(allowedMethodsRestricterConfig).includes("*")) {
      addServerHandler({
        handler: normalize(
          resolve(runtimeDir, "server/middleware/allowedMethodsRestricter")
        )
      });
    }
    const basicAuthConfig = nuxt.options.runtimeConfig.private.basicAuth;
    if (basicAuthConfig && (basicAuthConfig?.enabled || basicAuthConfig?.value?.enabled)) {
      addServerHandler({
        route: basicAuthConfig.route || "",
        handler: normalize(resolve(runtimeDir, "server/middleware/basicAuth"))
      });
    }
    nuxt.hook("nitro:build:before", hashBundledAssets);
    nuxt.hook("imports:dirs", (dirs) => {
      dirs.push(normalize(resolve(runtimeDir, "composables")));
    });
    const csrfConfig = nuxt.options.security.csrf;
    if (csrfConfig) {
      if (Object.keys(csrfConfig).length) {
        await installModule("nuxt-csurf", csrfConfig);
      }
      await installModule("nuxt-csurf");
    }
  }
});
function setGlobalSecurityRoute(nuxt, securityOptions) {
  nuxt.options.nitro.routeRules = defuReplaceArray(
    { "/**": { security: securityOptions } },
    nuxt.options.nitro.routeRules
  );
}
function mergeSecurityPerRoute(nuxt) {
  for (const route in nuxt.options.nitro.routeRules) {
    const rule = nuxt.options.nitro.routeRules[route];
    const { security, headers: standardHeaders } = rule;
    const standardHeadersAsObject = {};
    if (standardHeaders) {
      Object.entries(standardHeaders).forEach(([headerName, headerValue]) => {
        const optionKey = getKeyFromName(headerName);
        if (optionKey) {
          if (typeof headerValue === "string") {
            const objectValue = headerObjectFromString(optionKey, headerValue);
            standardHeadersAsObject[optionKey] = objectValue;
          } else {
            standardHeadersAsObject[optionKey] = headerValue;
            standardHeaders[headerName] = headerStringFromObject(optionKey, headerValue);
          }
        }
      });
    }
    const securityHeadersAsObject = {};
    if (security?.headers) {
      const { headers: securityHeaders } = security;
      Object.entries(securityHeaders).forEach(([key, value]) => {
        const optionKey = key;
        if ((optionKey === "contentSecurityPolicy" || optionKey === "permissionsPolicy" || optionKey === "strictTransportSecurity") && typeof value === "string") {
          const objectValue = headerObjectFromString(optionKey, value);
          securityHeadersAsObject[optionKey] = objectValue;
        } else if (value === "") {
          securityHeadersAsObject[optionKey] = false;
        } else {
          securityHeadersAsObject[optionKey] = value;
        }
      });
    }
    const mergedHeadersAsObject = defuReplaceArray(
      securityHeadersAsObject,
      standardHeadersAsObject
    );
    if (Object.keys(mergedHeadersAsObject).length) {
      nuxt.options.nitro.routeRules[route] = defuReplaceArray(
        {
          security: {
            headers: mergedHeadersAsObject
          }
        },
        rule
      );
    }
  }
}
function registerSecurityNitroPlugins(nuxt, securityOptions) {
  nuxt.hook("nitro:config", (config) => {
    config.plugins = config.plugins || [];
    if (securityOptions.rateLimiter) {
      const driver = securityOptions.rateLimiter.driver;
      if (driver) {
        const { name, options } = driver;
        config.storage = defu(
          config.storage,
          {
            "#storage-driver": {
              driver: name,
              options
            }
          }
        );
      }
    }
    if (securityOptions.hidePoweredBy) {
      config.externals = config.externals || {};
      config.externals.inline = config.externals.inline || [];
      config.externals.inline.push(
        normalize(fileURLToPath(new URL("./runtime", import.meta.url)))
      );
      config.plugins.push(
        normalize(
          fileURLToPath(
            new URL("./runtime/nitro/plugins/01-hidePoweredBy", import.meta.url)
          )
        )
      );
    }
    config.plugins.push(
      normalize(
        fileURLToPath(
          new URL("./runtime/nitro/plugins/02-securityHeaders", import.meta.url)
        )
      )
    );
    config.plugins.push(
      normalize(
        fileURLToPath(
          new URL("./runtime/nitro/plugins/02a-preprocessHtml", import.meta.url)
        )
      )
    );
    config.plugins.push(
      normalize(
        fileURLToPath(
          new URL("./runtime/nitro/plugins/03-subresourceIntegrity", import.meta.url)
        )
      )
    );
    config.plugins.push(
      normalize(
        fileURLToPath(
          new URL("./runtime/nitro/plugins/04-cspSsgHashes", import.meta.url)
        )
      )
    );
    config.plugins.push(
      normalize(
        fileURLToPath(
          new URL("./runtime/nitro/plugins/99-cspSsrNonce", import.meta.url)
        )
      )
    );
    config.plugins.push(
      normalize(
        fileURLToPath(
          new URL("./runtime/nitro/plugins/99b-recombineHtml", import.meta.url)
        )
      )
    );
  });
  nuxt.hook("nitro:init", (nitro) => {
    const securityPluginsPrefix = normalize(
      fileURLToPath(
        new URL("./runtime/nitro/plugins", import.meta.url)
      )
    );
    nitro.options.plugins.sort((a, b) => {
      if (a.startsWith(securityPluginsPrefix)) {
        if (b.startsWith(securityPluginsPrefix)) {
          return 0;
        } else {
          return 1;
        }
      } else {
        if (b.startsWith(securityPluginsPrefix)) {
          return -1;
        } else {
          return 0;
        }
      }
    });
    nitro.hooks.hook("prerender:config", (config) => {
      config.plugins?.sort((a, b) => {
        if (a?.startsWith(securityPluginsPrefix)) {
          if (b?.startsWith(securityPluginsPrefix)) {
            return 0;
          } else {
            return 1;
          }
        } else {
          if (b?.startsWith(securityPluginsPrefix)) {
            return -1;
          } else {
            return 0;
          }
        }
      });
    });
  });
}

export { module as default };
