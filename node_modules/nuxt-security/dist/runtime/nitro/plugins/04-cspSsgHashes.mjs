import { defineNitroPlugin, getRouteRules, setResponseHeader } from "#imports";
import * as cheerio from "cheerio";
import { headerStringFromObject } from "../../utils/headers.mjs";
import { generateHash } from "../../utils/hashes.mjs";
import { isPrerendering } from "../utils/index.mjs";
export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook("render:html", (html, { event }) => {
    if (!isPrerendering(event)) {
      return;
    }
    const { security } = getRouteRules(event);
    if (!security?.headers || !security.headers.contentSecurityPolicy) {
      return;
    }
    const scriptHashes = /* @__PURE__ */ new Set();
    const styleHashes = /* @__PURE__ */ new Set();
    const hashAlgorithm = "sha256";
    const cheerios = event.context.cheerios;
    if (security.ssg) {
      const { hashScripts, hashStyles } = security.ssg;
      const sections = ["body", "bodyAppend", "bodyPrepend", "head"];
      for (const section of sections) {
        cheerios[section].forEach(($) => {
          if (hashScripts) {
            $("script").each((i, script) => {
              const scriptText = $(script).text();
              const scriptAttrs = $(script).attr();
              const src = scriptAttrs?.src;
              const integrity = scriptAttrs?.integrity;
              if (!src && scriptText) {
                scriptHashes.add(`'${generateHash(scriptText, hashAlgorithm)}'`);
              } else if (src && integrity) {
                scriptHashes.add(`'${integrity}'`);
              }
            });
          }
          if (hashStyles) {
            $("style").each((i, style) => {
              const styleText = $(style).text();
              if (styleText) {
                styleHashes.add(`'${generateHash(styleText, hashAlgorithm)}'`);
              }
            });
          }
          $("link").each((i, link) => {
            const linkAttrs = $(link).attr();
            const integrity = linkAttrs?.integrity;
            if (integrity) {
              const rel = linkAttrs?.rel;
              if (rel === "stylesheet" && hashStyles) {
                styleHashes.add(`'${integrity}'`);
              } else if (rel === "preload" && hashScripts) {
                const as = linkAttrs.as;
                switch (as) {
                  case "script":
                  case "audioworklet":
                  case "paintworklet":
                  case "xlst":
                    scriptHashes.add(`'${integrity}'`);
                    break;
                  default:
                    break;
                }
              } else if (rel === "modulepreload" && hashScripts) {
                scriptHashes.add(`'${integrity}'`);
              }
            }
          });
        });
      }
    }
    const csp = security.headers.contentSecurityPolicy;
    const headerValue = generateCspRules(csp, scriptHashes, styleHashes);
    if (security.ssg && security.ssg.meta) {
      cheerios.head.push(cheerio.load(`<meta http-equiv="Content-Security-Policy" content="${headerValue}">`, null, false));
    }
    setResponseHeader(event, "Content-Security-Policy", headerValue);
  });
  function generateCspRules(csp, scriptHashes, styleHashes) {
    const generatedCsp = Object.fromEntries(
      Object.entries(csp).map(([key, value]) => {
        if (typeof value === "boolean") {
          return [key, value];
        }
        const sources = typeof value === "string" ? value.split(" ").map((token) => token.trim()).filter((token) => token) : value;
        const modifiedSources = sources.filter((source) => !source.startsWith("'nonce-"));
        const directive = key;
        if (directive === "script-src") {
          modifiedSources.push(...scriptHashes);
          return [directive, modifiedSources];
        } else if (directive === "style-src") {
          modifiedSources.push(...styleHashes);
          return [directive, modifiedSources];
        } else {
          return [directive, modifiedSources];
        }
      }).filter(([key]) => key !== "frame-ancestors")
    );
    return headerStringFromObject("contentSecurityPolicy", generatedCsp);
  }
});
