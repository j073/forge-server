import { createHash } from "node:crypto";
import { existsSync } from "node:fs";
import { readdir, readFile, writeFile, mkdir } from "node:fs/promises";
import { join } from "pathe";
export async function hashBundledAssets(nitro) {
  const hashAlgorithm = "sha384";
  const sriHashes = {};
  const { cdnURL: appCdnUrl = "", baseURL: appBaseUrl } = nitro.options.runtimeConfig.app;
  const publicAssets = nitro.options.publicAssets;
  for (const publicAsset of publicAssets) {
    const { dir, baseURL = "" } = publicAsset;
    if (existsSync(dir)) {
      const entries = await readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isFile()) {
          const fullPath = join(dir, entry.name);
          const fileContent = await readFile(fullPath);
          const hash = generateHash(fileContent, hashAlgorithm);
          const relativeUrl = join(baseURL, entry.name);
          let url;
          if (appCdnUrl) {
            url = new URL(relativeUrl, appCdnUrl).href;
          } else {
            url = join("/", appBaseUrl, relativeUrl);
          }
          sriHashes[url] = hash;
        }
      }
    }
  }
  const buildDir = nitro.options.buildDir;
  const integrityDir = join(buildDir, "integrity");
  if (!existsSync(integrityDir)) {
    await mkdir(integrityDir);
  }
  const hashFilePath = join(integrityDir, "sriHashes.json");
  await writeFile(hashFilePath, JSON.stringify(sriHashes));
  nitro.options.serverAssets.push({ dir: integrityDir, baseName: "integrity" });
}
export function generateHash(content, hashAlgorithm) {
  const hash = createHash(hashAlgorithm);
  hash.update(content);
  return `${hashAlgorithm}-${hash.digest("base64")}`;
}
